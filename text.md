# Понимание JVM (ответ)На первом этапе классы JvmComprehension, Object, Integer, System (из видимых) подгружаются в подсистему загрузчиков классов `ClassLoaders`, где происходит их поиск по трем группам классов Application ClassLoader, Platform ClassLoader, Bootstrap ClassLoader (используется хеш-код). При нахождении класса грузится их bytecode.Затем происходит подготовка классов к выполнению (связывание Linking)через Verify (проверка валидности кода(тот ли bytecode класса подгрузился)), Prepare (подготовка примитивов в статических полях(создаются стат.константы, которые планируется использовать)), Resolve (разрешение символьных ссылок, т.е. связывание классов).Далее происходит инициализация Initialization (выполняются static инициализаторы и инициализаторы static полей).На втором этапе `Runtime Data Area` (области памяти – основные три, но их всего около 7-8) подгружаются bytecode в Metaspace(область памяти, в котором хранится мета-информация (данные о классе, константы)). Также имеется Stack(хранит примитивные объекты) и heap(хранит ссылочные объекты)В данном случае на примере задания в Metaspace подгружаются bytecode с классами JvmComprehension.class и system classes.Дальше в Stack под каждую функцию выделяется фрейм, в рамках которого текущий поток работает с переменными и операндами.Создается:- main(int i = 1, o, ii = 2)- printAll (o, int i, ii, uselessVar = 700)- System.out.println(o, int i, ii)- System.out.println(string "finished")  В heap хранятся ссылочные объекты (Object(//2, //4, //6), Integer(//3, //4, //5) String(//6 и //7))`Execution Engine`. Во время выполнения байт-код в ".class" файле использует интепретатор (строка за строкой) и компилятор Just In Time (если метод вызывается слишком часто - то компилируется его код и сохраняется в кэше).Garbage Collector (сборщик мусора) периодически собирает объекты из памяти (хипа), которые больше не используются.Для сборки мусора происходит приостановка программы - Stop The World пауза (останавливаются все потоки).Недостижимые объекты удаляются.А достижимые обычно группируются по времени жизни (поколения).Сборщик мусора настраиваем на частичную проверку (не перегружать программу) по методу - обход графа достижимых объектов (mark-and-sweep, copying collection).Если объект выдерживает первую и вторую проверку, то его все реже и реже будут проверять.